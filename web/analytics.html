<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Analytics - Dechen Study</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <style>
    :root {
      --bg: #0a0a0f;
      --bg-raised: #12121a;
      --bg-card: #16161f;
      --bg-card-hover: #1a1a25;
      --bg-input: #1e1e2a;
      --ink: #e8e8ed;
      --body: #a0a0b0;
      --muted: #6b6b80;
      --primary: #818cf8;
      --primary-dim: rgba(129, 140, 248, 0.15);
      --accent-green: #34d399;
      --accent-amber: #fbbf24;
      --accent-rose: #fb7185;
      --line: #1e1e2a;
      --line-light: rgba(255,255,255,0.06);
      --shadow-sm: 0 1px 2px rgba(0,0,0,0.3);
      --shadow: 0 4px 16px rgba(0,0,0,0.4);
      --shadow-lg: 0 8px 32px rgba(0,0,0,0.5);
      --radius: 16px;
      --radius-sm: 10px;
      --radius-xs: 6px;
    }
    * { box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--body);
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .topbar {
      position: sticky;
      top: 0;
      z-index: 100;
      background: rgba(10, 10, 15, 0.8);
      backdrop-filter: blur(16px) saturate(180%);
      -webkit-backdrop-filter: blur(16px) saturate(180%);
      border-bottom: 1px solid var(--line-light);
      padding: 0.875rem 1.5rem;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
    }
    .topbar-title {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--ink);
      margin: 0;
      letter-spacing: -0.02em;
    }
    .nav-links {
      display: flex;
      flex-wrap: wrap;
      gap: 0.25rem;
      align-items: center;
    }
    .nav-links a {
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--muted);
      text-decoration: none;
      padding: 0.375rem 0.625rem;
      border-radius: var(--radius-xs);
      transition: all 0.15s ease;
    }
    .nav-links a:hover {
      background: var(--primary-dim);
      color: var(--primary);
    }
    .filter-wrap {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .filter-wrap label {
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--muted);
    }
    .filter-select {
      font-family: 'Inter', sans-serif;
      font-size: 0.8125rem;
      font-weight: 500;
      padding: 0.4rem 2rem 0.4rem 0.75rem;
      border: 1px solid var(--line);
      border-radius: var(--radius-xs);
      background: var(--bg-input);
      color: var(--ink);
      cursor: pointer;
      min-width: 160px;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='%236b6b80' viewBox='0 0 16 16'%3E%3Cpath d='M4 6l4 4 4-4'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 0.75rem center;
      transition: border-color 0.15s ease;
    }
    .filter-select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px var(--primary-dim);
    }
    .filter-select option {
      background: var(--bg-card);
      color: var(--ink);
    }

    .container {
      max-width: 1040px;
      margin: 0 auto;
      padding: 2rem 1.5rem;
    }

    .section {
      scroll-margin-top: 4rem;
      margin-bottom: 2.5rem;
    }
    .section-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.06em;
      margin: 0 0 1rem;
      padding-bottom: 0;
      border-bottom: none;
    }
    .card {
      background: var(--bg-card);
      border: 1px solid var(--line-light);
      border-radius: var(--radius);
      padding: 1.5rem;
      margin-bottom: 1rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .card:hover {
      border-color: rgba(255,255,255,0.1);
      box-shadow: var(--shadow);
    }
    .card.chart-card {
      padding: 1.25rem;
    }
    .chart-wrap {
      position: relative;
      height: 240px;
    }
    .chart-wrap.chart-tall { height: 300px; }
    .chart-wrap.chart-wide { height: 340px; }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(170px, 1fr));
      gap: 0.75rem;
    }
    .stat-item {
      text-align: left;
      padding: 1.25rem;
      background: var(--bg-card);
      border-radius: var(--radius);
      border: 1px solid var(--line-light);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .stat-item:hover {
      border-color: rgba(255,255,255,0.1);
      box-shadow: var(--shadow);
    }
    .stat-value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--ink);
      display: block;
      line-height: 1.1;
      letter-spacing: -0.03em;
    }
    .stat-label {
      font-size: 0.8125rem;
      font-weight: 500;
      color: var(--muted);
      margin-top: 0.375rem;
      display: block;
    }
    .stat-item:nth-child(1) .stat-value { color: var(--primary); }
    .stat-item:nth-child(2) .stat-value { color: var(--accent-green); }
    .stat-item:nth-child(3) .stat-value { color: var(--accent-amber); }
    .stat-item:nth-child(4) .stat-value { color: var(--accent-rose); }
    .stat-item:nth-child(5) .stat-value { color: #a78bfa; }

    .error-card {
      background: rgba(239, 68, 68, 0.1);
      border-color: rgba(239, 68, 68, 0.2);
      color: #fca5a5;
    }
    .loading-card {
      color: var(--muted);
      text-align: center;
      padding: 3rem 2rem;
      font-size: 0.875rem;
    }
    .loading-card::before {
      content: '';
      display: block;
      width: 24px;
      height: 24px;
      border: 2px solid var(--line);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin: 0 auto 1rem;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .filter-note {
      font-size: 0.75rem;
      color: var(--primary);
      background: var(--primary-dim);
      padding: 0.375rem 0.75rem;
      border-radius: var(--radius-xs);
      width: 100%;
    }

    @media (max-width: 640px) {
      .topbar { flex-direction: column; align-items: stretch; gap: 0.75rem; }
      .filter-wrap { margin-left: 0; }
      .chart-wrap { height: 200px; }
      .chart-wrap.chart-tall { height: 260px; }
      .chart-wrap.chart-wide { height: 280px; }
      .stats-grid { grid-template-columns: repeat(2, 1fr); }
      .stat-value { font-size: 1.5rem; }
    }
  </style>
</head>
<body>
  <header class="topbar">
    <h1 class="topbar-title">Dechen Study Analytics</h1>
    <nav class="nav-links" id="nav-links" style="display:none;">
      <a href="#section-summary">Summary</a>
      <a href="#section-by-text">By text</a>
      <a href="#section-by-mode">By mode</a>
      <a href="#section-over-time">Over time</a>
      <a href="#section-over-time-by-text">Over time by text</a>
      <a href="#section-by-country">By country</a>
      <a href="#section-event-types">Event types</a>
    </nav>
    <div class="filter-wrap" id="filter-wrap" style="display:none;">
      <label for="text-filter">Filter by text</label>
      <select id="text-filter" class="filter-select" aria-label="Filter by text">
        <option value="">All texts</option>
      </select>
    </div>
    <p class="filter-note" id="filter-note" style="display:none; margin:0;"></p>
  </header>

  <div id="config-msg" class="container" style="padding-top:2rem;">
    <div class="card error-card" id="config-err" style="display:none;">
      Analytics require Supabase config. Set SUPABASE_URL and SUPABASE_ANON_KEY in Vercel env vars, or create web/supabase_config.js for local dev.
    </div>
  </div>
  <div id="loading" class="container" style="padding-top:2rem;">
    <div class="card loading-card" id="loading-el">Loading analytics&hellip;</div>
  </div>

  <main id="content" class="container" style="display:none;">
    <section id="section-summary" class="section">
      <h2 class="section-title">Summary</h2>
      <div class="stats-grid">
        <div class="stat-item">
          <span class="stat-value" id="total-events">0</span>
          <span class="stat-label">Total events</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="unique-sessions">0</span>
          <span class="stat-label">Unique sessions</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="unique-anon-users">0</span>
          <span class="stat-label">Anonymous users</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="unique-auth-users">0</span>
          <span class="stat-label">Logged-in users</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="quiz-attempts">0</span>
          <span class="stat-label">Quiz attempts</span>
        </div>
      </div>
    </section>

    <section id="section-by-text" class="section">
      <h2 class="section-title">Events by text</h2>
      <div class="card chart-card">
        <div class="chart-wrap">
          <canvas id="chart-text"></canvas>
        </div>
      </div>
    </section>

    <section id="section-by-mode" class="section">
      <h2 class="section-title">Events by mode</h2>
      <div class="card chart-card">
        <div class="chart-wrap chart-wide">
          <canvas id="chart-mode"></canvas>
        </div>
      </div>
    </section>

    <section id="section-over-time" class="section">
      <h2 class="section-title">Events over time (30 days)</h2>
      <div class="card chart-card">
        <div class="chart-wrap">
          <canvas id="chart-time"></canvas>
        </div>
      </div>
    </section>

    <section id="section-over-time-by-text" class="section">
      <h2 class="section-title">Events over time by text (30 days)</h2>
      <div class="card chart-card">
        <div class="chart-wrap chart-tall">
          <canvas id="chart-time-by-text"></canvas>
        </div>
      </div>
    </section>

    <section id="section-by-country" class="section">
      <h2 class="section-title">Events by country</h2>
      <div class="card chart-card">
        <div class="chart-wrap chart-wide">
          <canvas id="chart-country"></canvas>
        </div>
      </div>
    </section>

    <section id="section-event-types" class="section">
      <h2 class="section-title">Top event types</h2>
      <div class="card chart-card">
        <div class="chart-wrap chart-tall">
          <canvas id="chart-type"></canvas>
        </div>
      </div>
    </section>
  </main>

  <script src="supabase_config.js"></script>
  <script>
(function() {
  const palette = ['#818cf8', '#34d399', '#fbbf24', '#fb7185', '#a78bfa', '#38bdf8', '#f472b6', '#2dd4bf'];
  const gridColor = 'rgba(255,255,255,0.06)';
  const tickColor = '#6b6b80';
  let rawData = null;
  let chartInstances = {};

  Chart.defaults.color = tickColor;
  Chart.defaults.borderColor = gridColor;
  Chart.defaults.font.family = "'Inter', sans-serif";
  Chart.defaults.font.size = 11;

  function byText(rows, textId) {
    if (!textId) return rows;
    return rows.filter(r => (r.text_id || '') === textId);
  }

  function filterData(d, textId) {
    if (!d) return d;
    return {
      ...d,
      events_by_mode: d.events_by_mode,
      events_by_mode_and_text: byText(d.events_by_mode_and_text || [], textId),
      events_by_type: d.events_by_type,
      events_by_text: textId ? (d.events_by_text || []).filter(r => r.text_id === textId) : (d.events_by_text || []),
      events_over_time: d.events_over_time,
      events_over_time_by_text: byText(d.events_over_time_by_text || [], textId),
      quiz_summary: d.quiz_summary,
      totals: d.totals
    };
  }

  function destroyCharts() {
    Object.keys(chartInstances).forEach(key => {
      if (chartInstances[key]) {
        chartInstances[key].destroy();
        chartInstances[key] = null;
      }
    });
    chartInstances = {};
  }

  function renderCharts(d) {
    destroyCharts();
    const modeData = d.events_by_mode || [];
    const modeByTextData = d.events_by_mode_and_text || [];
    const timeData = d.events_over_time || [];
    const typeData = d.events_by_type || [];
    const textData = d.events_by_text || [];
    const timeByTextData = d.events_over_time_by_text || [];
    const countryData = d.events_by_country || [];

    const modeLabels = modeData.map(r => r.mode || '');
    const byModeText = {};
    modeByTextData.forEach(r => { byModeText[(r.mode || '') + '\0' + (r.text_id || '')] = r.count; });
    const textOrder = textData.map(r => r.text_id);
    const modeTextIds = [...new Set(modeByTextData.map(r => r.text_id))].filter(Boolean).sort((a, b) => {
      const i = textOrder.indexOf(a);
      const j = textOrder.indexOf(b);
      return (i === -1 ? 999 : i) - (j === -1 ? 999 : j);
    });
    const stackedModeDatasets = modeTextIds.slice(0, 8).map((textId, i) => ({
      label: textId,
      data: modeLabels.map(m => byModeText[m + '\0' + textId] || 0),
      backgroundColor: palette[i % palette.length],
      borderRadius: 4,
      stack: 'mode'
    }));
    const hasStackedData = stackedModeDatasets.some(ds => ds.data.some(v => v > 0));

    chartInstances.mode = new Chart(document.getElementById('chart-mode'), {
      type: 'bar',
      data: {
        labels: modeLabels,
        datasets: hasStackedData ? stackedModeDatasets : [{ label: 'Events', data: modeData.map(r => r.count), backgroundColor: palette[0], borderRadius: 4 }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: hasStackedData, labels: { boxWidth: 12, padding: 16 } }
        },
        scales: {
          x: { stacked: hasStackedData, grid: { display: false } },
          y: { stacked: hasStackedData, beginAtZero: true, grid: { color: gridColor } }
        }
      }
    });

    const textColors = textData.map((_, i) => palette[i % palette.length]);
    chartInstances.text = new Chart(document.getElementById('chart-text'), {
      type: 'bar',
      data: {
        labels: textData.map(r => r.text_id || ''),
        datasets: [{ label: 'Events', data: textData.map(r => r.count), backgroundColor: textColors, borderRadius: 4 }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
          x: { grid: { display: false } },
          y: { beginAtZero: true, grid: { color: gridColor } }
        }
      }
    });

    const gradient = document.getElementById('chart-time').getContext('2d');
    const fill = gradient.createLinearGradient(0, 0, 0, 240);
    fill.addColorStop(0, 'rgba(129, 140, 248, 0.25)');
    fill.addColorStop(1, 'rgba(129, 140, 248, 0)');

    chartInstances.time = new Chart(document.getElementById('chart-time'), {
      type: 'line',
      data: {
        labels: timeData.map(r => r.day || ''),
        datasets: [{
          label: 'Events',
          data: timeData.map(r => r.count),
          borderColor: palette[0],
          backgroundColor: fill,
          fill: true,
          tension: 0.35,
          borderWidth: 2,
          pointRadius: 0,
          pointHoverRadius: 5,
          pointHoverBackgroundColor: palette[0]
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
          x: { grid: { display: false } },
          y: { beginAtZero: true, grid: { color: gridColor } }
        },
        interaction: { intersect: false, mode: 'index' }
      }
    });

    const days = [...new Set(timeByTextData.map(r => r.day))].sort();
    const timeTextIds = [...new Set(timeByTextData.map(r => r.text_id))].sort((a, b) => {
      const i = textOrder.indexOf(a);
      const j = textOrder.indexOf(b);
      return (i === -1 ? 999 : i) - (j === -1 ? 999 : j);
    });
    const byDayText = {};
    timeByTextData.forEach(r => { byDayText[r.day + '\0' + r.text_id] = r.count; });
    const timeByTextDatasets = timeTextIds.slice(0, 8).map((textId, i) => ({
      label: textId,
      data: days.map(d => byDayText[d + '\0' + textId] || 0),
      borderColor: palette[i % palette.length],
      fill: false,
      tension: 0.35,
      borderWidth: 2,
      pointRadius: 0,
      pointHoverRadius: 5,
      pointHoverBackgroundColor: palette[i % palette.length]
    }));

    chartInstances.timeByText = new Chart(document.getElementById('chart-time-by-text'), {
      type: 'line',
      data: { labels: days, datasets: timeByTextDatasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { labels: { boxWidth: 12, padding: 16 } } },
        scales: {
          x: { grid: { display: false } },
          y: { beginAtZero: true, grid: { color: gridColor } }
        },
        interaction: { intersect: false, mode: 'index' }
      }
    });

    const countryLabels = countryData.map(r => r.country_code || '');
    const countryColors = countryLabels.map((_, i) => palette[i % palette.length]);
    chartInstances.country = new Chart(document.getElementById('chart-country'), {
      type: 'bar',
      data: {
        labels: countryLabels,
        datasets: [{ label: 'Events', data: countryData.map(r => r.count), backgroundColor: countryColors, borderRadius: 4 }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
          x: { grid: { display: false } },
          y: { beginAtZero: true, grid: { color: gridColor } }
        }
      }
    });

    const typeLabels = typeData.map(r => (r.event_name || '') + (r.mode ? ' (' + r.mode + ')' : ''));
    chartInstances.type = new Chart(document.getElementById('chart-type'), {
      type: 'bar',
      data: {
        labels: typeLabels,
        datasets: [{ label: 'Events', data: typeData.map(r => r.count), backgroundColor: palette[0], borderRadius: 4 }]
      },
      options: {
        indexAxis: 'y',
        responsive: true,
        maintainAspectRatio: false,
        plugins: { legend: { display: false } },
        scales: {
          x: { beginAtZero: true, grid: { color: gridColor } },
          y: { grid: { display: false } }
        }
      }
    });
  }

  const url = typeof window.SUPABASE_URL !== 'undefined' ? window.SUPABASE_URL : '';
  const key = typeof window.SUPABASE_ANON_KEY !== 'undefined' ? window.SUPABASE_ANON_KEY : '';
  if (!url || !key) {
    document.getElementById('loading-el').style.display = 'none';
    document.getElementById('config-err').style.display = 'block';
    document.getElementById('loading').style.display = 'block';
    return;
  }

  const supabase = window.supabase.createClient(url, key);
  supabase.rpc('analytics_dashboard_json').then(({ data, error }) => {
    document.getElementById('loading').style.display = 'none';
    if (error) {
      document.getElementById('config-err').textContent = 'Error: ' + error.message;
      document.getElementById('config-err').style.display = 'block';
      document.getElementById('config-msg').style.display = 'block';
      return;
    }
    rawData = data || {};
    document.getElementById('content').style.display = 'block';
    document.getElementById('nav-links').style.display = 'flex';
    document.getElementById('filter-wrap').style.display = 'flex';

    const textData = rawData.events_by_text || [];
    const select = document.getElementById('text-filter');
    textData.forEach(r => {
      const opt = document.createElement('option');
      opt.value = r.text_id || '';
      opt.textContent = r.text_id || '';
      select.appendChild(opt);
    });
    select.addEventListener('change', () => applyFilter(select.value || null));

    const noteEl = document.getElementById('filter-note');
    function applyFilter(textId) {
      if (!rawData) return;
      if (noteEl) {
        if (textId) {
          noteEl.style.display = 'block';
          noteEl.textContent = 'Charts filtered to: ' + textId + '. Summary counts are for all texts.';
        } else {
          noteEl.style.display = 'none';
        }
      }
      const d = filterData(rawData, textId || null);
    document.getElementById('total-events').textContent = (d.totals && d.totals.total_events) || 0;
    document.getElementById('unique-sessions').textContent = (d.totals && d.totals.unique_sessions) || 0;
    document.getElementById('unique-anon-users').textContent = (d.totals && d.totals.unique_anon_users) != null ? d.totals.unique_anon_users : 0;
    document.getElementById('unique-auth-users').textContent = (d.totals && d.totals.unique_authenticated_users) != null ? d.totals.unique_authenticated_users : 0;
    document.getElementById('quiz-attempts').textContent = (d.quiz_summary && d.quiz_summary.quiz_attempts) || 0;
    renderCharts(d);
  }

  applyFilter(null);
  });
})();
  </script>
</body>
</html>
